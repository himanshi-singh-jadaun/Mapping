{"ast":null,"code":"import _objectSpread from \"C:/Users/HIMANSHI/Desktop/Mapping/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/HIMANSHI/Desktop/Mapping/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/HIMANSHI/Desktop/Mapping/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { transformToViewState, applyViewStateToTransform, cloneTransform } from '../utils/transform';\nimport { normalizeStyle } from '../utils/style-utils';\nimport { deepEqual } from '../utils/deep-equal';\nvar pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nvar cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nvar otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nvar settingNames = ['minZoom', 'maxZoom', 'minPitch', 'maxPitch', 'maxBounds', 'projection', 'renderWorldCopies'];\nvar handlerNames = ['scrollZoom', 'boxZoom', 'dragRotate', 'dragPan', 'keyboard', 'doubleClickZoom', 'touchZoomRotate', 'touchPitch'];\n/**\n * A wrapper for mapbox-gl's Map class\n */\nvar Mapbox = /*#__PURE__*/function () {\n  function Mapbox(MapClass, props, container) {\n    var _this = this;\n    _classCallCheck(this, Mapbox);\n    // mapboxgl.Map instance. Not using type here because we are accessing\n    // private members and methods\n    this._map = null;\n    // Internal states\n    this._internalUpdate = false;\n    this._inRender = false;\n    this._hoveredFeatures = null;\n    this._deferredEvents = {\n      move: false,\n      zoom: false,\n      pitch: false,\n      rotate: false\n    };\n    this._onEvent = function (e) {\n      // @ts-ignore\n      var cb = _this.props[otherEvents[e.type]];\n      if (cb) {\n        cb(e);\n      }\n    };\n    this._onPointerEvent = function (e) {\n      if (e.type === 'mousemove' || e.type === 'mouseout') {\n        _this._updateHover(e);\n      }\n      // @ts-ignore\n      var cb = _this.props[pointerEvents[e.type]];\n      if (cb) {\n        if (_this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n          e.features = _this._hoveredFeatures || _this._queryRenderedFeatures(e.point);\n        }\n        cb(e);\n        delete e.features;\n      }\n    };\n    this._onCameraEvent = function (e) {\n      if (!_this._internalUpdate) {\n        // @ts-ignore\n        var cb = _this.props[cameraEvents[e.type]];\n        if (cb) {\n          cb(e);\n        }\n      }\n      if (e.type in _this._deferredEvents) {\n        _this._deferredEvents[e.type] = false;\n      }\n    };\n    this._MapClass = MapClass;\n    this.props = props;\n    this._initialize(container);\n  }\n  _createClass(Mapbox, [{\n    key: \"map\",\n    get: function get() {\n      return this._map;\n    }\n  }, {\n    key: \"transform\",\n    get: function get() {\n      return this._renderTransform;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      var oldProps = this.props;\n      this.props = props;\n      var settingsChanged = this._updateSettings(props, oldProps);\n      if (settingsChanged) {\n        this._createShadowTransform(this._map);\n      }\n      var sizeChanged = this._updateSize(props);\n      var viewStateChanged = this._updateViewState(props, true);\n      this._updateStyle(props, oldProps);\n      this._updateStyleComponents(props, oldProps);\n      this._updateHandlers(props, oldProps);\n      // If 1) view state has changed to match props and\n      //    2) the props change is not triggered by map events,\n      // it's driven by an external state change. Redraw immediately\n      if (settingsChanged || sizeChanged || viewStateChanged && !this._map.isMoving()) {\n        this.redraw();\n      }\n    }\n  }, {\n    key: \"_initialize\",\n    value: /* eslint-disable complexity,max-statements */\n    function _initialize(container) {\n      var _this2 = this;\n      var props = this.props;\n      var mapOptions = _objectSpread(_objectSpread(_objectSpread({}, props), props.initialViewState), {}, {\n        accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n        container: container,\n        style: normalizeStyle(props.mapStyle)\n      });\n      var viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n      Object.assign(mapOptions, {\n        center: [viewState.longitude || 0, viewState.latitude || 0],\n        zoom: viewState.zoom || 0,\n        pitch: viewState.pitch || 0,\n        bearing: viewState.bearing || 0\n      });\n      if (props.gl) {\n        // eslint-disable-next-line\n        var getContext = HTMLCanvasElement.prototype.getContext;\n        // Hijack canvas.getContext to return our own WebGLContext\n        // This will be called inside the mapboxgl.Map constructor\n        // @ts-expect-error\n        HTMLCanvasElement.prototype.getContext = function () {\n          // Unhijack immediately\n          HTMLCanvasElement.prototype.getContext = getContext;\n          return props.gl;\n        };\n      }\n      var map = new this._MapClass(mapOptions);\n      // Props that are not part of constructor options\n      if (viewState.padding) {\n        map.setPadding(viewState.padding);\n      }\n      if (props.cursor) {\n        map.getCanvas().style.cursor = props.cursor;\n      }\n      this._createShadowTransform(map);\n      // Hack\n      // Insert code into map's render cycle\n      var renderMap = map._render;\n      map._render = function (arg) {\n        _this2._inRender = true;\n        renderMap.call(map, arg);\n        _this2._inRender = false;\n      };\n      var runRenderTaskQueue = map._renderTaskQueue.run;\n      map._renderTaskQueue.run = function (arg) {\n        runRenderTaskQueue.call(map._renderTaskQueue, arg);\n        _this2._onBeforeRepaint();\n      };\n      map.on('render', function () {\n        return _this2._onAfterRepaint();\n      });\n      // Insert code into map's event pipeline\n      var fireEvent = map.fire;\n      map.fire = this._fireEvent.bind(this, fireEvent);\n      // add listeners\n      map.on('resize', function () {\n        _this2._renderTransform.resize(map.transform.width, map.transform.height);\n      });\n      map.on('styledata', function () {\n        return _this2._updateStyleComponents(_this2.props, {});\n      });\n      map.on('sourcedata', function () {\n        return _this2._updateStyleComponents(_this2.props, {});\n      });\n      for (var eventName in pointerEvents) {\n        map.on(eventName, this._onPointerEvent);\n      }\n      for (var _eventName in cameraEvents) {\n        map.on(_eventName, this._onCameraEvent);\n      }\n      for (var _eventName2 in otherEvents) {\n        map.on(_eventName2, this._onEvent);\n      }\n      this._map = map;\n    }\n    /* eslint-enable complexity,max-statements */\n  }, {\n    key: \"recycle\",\n    value: function recycle() {\n      // Clean up unnecessary elements before storing for reuse.\n      var container = this.map.getContainer();\n      var children = container.querySelector('[mapboxgl-children]');\n      children === null || children === void 0 ? void 0 : children.remove();\n      Mapbox.savedMaps.push(this);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._map.remove();\n    }\n    // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n    // render cycle, which is managed by Mapbox's animation loop.\n    // This removes the synchronization issue caused by requestAnimationFrame.\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      var map = this._map;\n      // map._render will throw error if style does not exist\n      // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n      //   /src/ui/map.js#L1834\n      if (!this._inRender && map.style) {\n        // cancel the scheduled update\n        if (map._frame) {\n          map._frame.cancel();\n          map._frame = null;\n        }\n        // the order is important - render() may schedule another update\n        map._render();\n      }\n    }\n  }, {\n    key: \"_createShadowTransform\",\n    value: function _createShadowTransform(map) {\n      var renderTransform = cloneTransform(map.transform);\n      map.painter.transform = renderTransform;\n      this._renderTransform = renderTransform;\n    }\n    /* Trigger map resize if size is controlled\n       @param {object} nextProps\n       @returns {bool} true if size has changed\n     */\n  }, {\n    key: \"_updateSize\",\n    value: function _updateSize(nextProps) {\n      // Check if size is controlled\n      var viewState = nextProps.viewState;\n      if (viewState) {\n        var map = this._map;\n        if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n          map.resize();\n          return true;\n        }\n      }\n      return false;\n    }\n    // Adapted from map.jumpTo\n    /* Update camera to match props\n       @param {object} nextProps\n       @param {bool} triggerEvents - should fire camera events\n       @returns {bool} true if anything is changed\n     */\n  }, {\n    key: \"_updateViewState\",\n    value: function _updateViewState(nextProps, triggerEvents) {\n      if (this._internalUpdate) {\n        return false;\n      }\n      var map = this._map;\n      var tr = this._renderTransform;\n      // Take a snapshot of the transform before mutation\n      var zoom = tr.zoom,\n        pitch = tr.pitch,\n        bearing = tr.bearing;\n      var isMoving = map.isMoving();\n      if (isMoving) {\n        // All movement of the camera is done relative to the sea level\n        tr.cameraElevationReference = 'sea';\n      }\n      var changed = applyViewStateToTransform(tr, _objectSpread(_objectSpread({}, transformToViewState(map.transform)), nextProps));\n      if (isMoving) {\n        // Reset camera reference\n        tr.cameraElevationReference = 'ground';\n      }\n      if (changed && triggerEvents) {\n        var deferredEvents = this._deferredEvents;\n        // Delay DOM control updates to the next render cycle\n        deferredEvents.move = true;\n        deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);\n        deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);\n        deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);\n      }\n      // Avoid manipulating the real transform when interaction/animation is ongoing\n      // as it would interfere with Mapbox's handlers\n      if (!isMoving) {\n        applyViewStateToTransform(map.transform, nextProps);\n      }\n      return changed;\n    }\n    /* Update camera constraints and projection settings to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n  }, {\n    key: \"_updateSettings\",\n    value: function _updateSettings(nextProps, currProps) {\n      var map = this._map;\n      var changed = false;\n      for (var _i = 0, _settingNames = settingNames; _i < _settingNames.length; _i++) {\n        var propName = _settingNames[_i];\n        if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n          changed = true;\n          map[\"set\".concat(propName[0].toUpperCase()).concat(propName.slice(1))](nextProps[propName]);\n        }\n      }\n      return changed;\n    }\n    /* Update map style to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if style is changed\n     */\n  }, {\n    key: \"_updateStyle\",\n    value: function _updateStyle(nextProps, currProps) {\n      if (nextProps.cursor !== currProps.cursor) {\n        this._map.getCanvas().style.cursor = nextProps.cursor;\n      }\n      if (nextProps.mapStyle !== currProps.mapStyle) {\n        var options = {\n          diff: nextProps.styleDiffing\n        };\n        if ('localIdeographFontFamily' in nextProps) {\n          options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n        }\n        this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);\n        return true;\n      }\n      return false;\n    }\n    /* Update fog, light and terrain to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n  }, {\n    key: \"_updateStyleComponents\",\n    value: function _updateStyleComponents(nextProps, currProps) {\n      var map = this._map;\n      var changed = false;\n      if (map.style.loaded()) {\n        if ('light' in nextProps && !deepEqual(nextProps.light, currProps.light)) {\n          changed = true;\n          map.setLight(nextProps.light);\n        }\n        if ('fog' in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {\n          changed = true;\n          map.setFog(nextProps.fog);\n        }\n        if ('terrain' in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {\n          if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n            changed = true;\n            map.setTerrain(nextProps.terrain);\n          }\n        }\n      }\n      return changed;\n    }\n    /* Update interaction handlers to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n  }, {\n    key: \"_updateHandlers\",\n    value: function _updateHandlers(nextProps, currProps) {\n      var map = this._map;\n      var changed = false;\n      for (var _i2 = 0, _handlerNames = handlerNames; _i2 < _handlerNames.length; _i2++) {\n        var propName = _handlerNames[_i2];\n        var newValue = nextProps[propName];\n        if (!deepEqual(newValue, currProps[propName])) {\n          changed = true;\n          if (newValue) {\n            map[propName].enable(newValue);\n          } else {\n            map[propName].disable();\n          }\n        }\n      }\n      return changed;\n    }\n  }, {\n    key: \"_queryRenderedFeatures\",\n    value: function _queryRenderedFeatures(point) {\n      var map = this._map;\n      var _this$props$interacti = this.props.interactiveLayerIds,\n        interactiveLayerIds = _this$props$interacti === void 0 ? [] : _this$props$interacti;\n      try {\n        return map.queryRenderedFeatures(point, {\n          layers: interactiveLayerIds.filter(map.getLayer.bind(map))\n        });\n      } catch (_a) {\n        // May fail if style is not loaded\n        return [];\n      }\n    }\n  }, {\n    key: \"_updateHover\",\n    value: function _updateHover(e) {\n      var _a;\n      var props = this.props;\n      var shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n      if (shouldTrackHoveredFeatures) {\n        var eventType = e.type;\n        var wasHovering = ((_a = this._hoveredFeatures) === null || _a === void 0 ? void 0 : _a.length) > 0;\n        var features = this._queryRenderedFeatures(e.point);\n        var isHovering = features.length > 0;\n        if (!isHovering && wasHovering) {\n          e.type = 'mouseleave';\n          this._onPointerEvent(e);\n        }\n        this._hoveredFeatures = features;\n        if (isHovering && !wasHovering) {\n          e.type = 'mouseenter';\n          this._onPointerEvent(e);\n        }\n        e.type = eventType;\n      } else {\n        this._hoveredFeatures = null;\n      }\n    }\n  }, {\n    key: \"_fireEvent\",\n    value: function _fireEvent(baseFire, event, properties) {\n      var map = this._map;\n      var tr = map.transform;\n      var eventType = typeof event === 'string' ? event : event.type;\n      if (eventType === 'move') {\n        this._updateViewState(this.props, false);\n      }\n      if (eventType in cameraEvents) {\n        if (typeof event === 'object') {\n          event.viewState = transformToViewState(tr);\n        }\n        if (this._map.isMoving()) {\n          // Replace map.transform with ours during the callbacks\n          map.transform = this._renderTransform;\n          baseFire.call(map, event, properties);\n          map.transform = tr;\n          return map;\n        }\n      }\n      baseFire.call(map, event, properties);\n      return map;\n    }\n    // All camera manipulations are complete, ready to repaint\n  }, {\n    key: \"_onBeforeRepaint\",\n    value: function _onBeforeRepaint() {\n      var _this3 = this;\n      var map = this._map;\n      // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n      this._internalUpdate = true;\n      for (var eventType in this._deferredEvents) {\n        if (this._deferredEvents[eventType]) {\n          map.fire(eventType);\n        }\n      }\n      this._internalUpdate = false;\n      var tr = this._map.transform;\n      // Make sure camera matches the current props\n      this._map.transform = this._renderTransform;\n      this._onAfterRepaint = function () {\n        // Restores camera state before render/load events are fired\n        _this3._map.transform = tr;\n      };\n    }\n  }], [{\n    key: \"reuse\",\n    value: function reuse(props, container) {\n      var that = Mapbox.savedMaps.pop();\n      if (!that) {\n        return null;\n      }\n      var map = that.map;\n      // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n      // intoto the new container from the props.\n      // Step 1: reparenting child nodes from old container to new container\n      var oldContainer = map.getContainer();\n      container.className = oldContainer.className;\n      while (oldContainer.childNodes.length > 0) {\n        container.appendChild(oldContainer.childNodes[0]);\n      }\n      // Step 2: replace the internal container with new container from the react component\n      // @ts-ignore\n      map._container = container;\n      // With maplibre-gl as mapLib, map uses ResizeObserver to observe when its container resizes.\n      // When reusing the saved map, we need to disconnect the observer and observe the new container.\n      // Step 3: telling the ResizeObserver to disconnect and observe the new container\n      // @ts-ignore\n      var resizeObserver = map._resizeObserver;\n      if (resizeObserver) {\n        resizeObserver.disconnect();\n        resizeObserver.observe(container);\n      }\n      // Step 4: apply new props\n      that.setProps(_objectSpread(_objectSpread({}, props), {}, {\n        styleDiffing: false\n      }));\n      map.resize();\n      var initialViewState = props.initialViewState;\n      if (initialViewState) {\n        if (initialViewState.bounds) {\n          map.fitBounds(initialViewState.bounds, _objectSpread(_objectSpread({}, initialViewState.fitBoundsOptions), {}, {\n            duration: 0\n          }));\n        } else {\n          that._updateViewState(initialViewState, false);\n        }\n      }\n      // Simulate load event\n      if (map.isStyleLoaded()) {\n        map.fire('load');\n      } else {\n        map.once('styledata', function () {\n          return map.fire('load');\n        });\n      }\n      // Force reload\n      // @ts-ignore\n      map._update();\n      return that;\n    }\n  }]);\n  return Mapbox;\n}();\nexport { Mapbox as default };\nMapbox.savedMaps = [];\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\nfunction getAccessTokenFromEnv() {\n  var accessToken = null;\n  /* global location, process */\n  if (typeof location !== 'undefined') {\n    var match = /access_token=([^&\\/]*)/.exec(location.search);\n    accessToken = match && match[1];\n  }\n  // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n  try {\n    accessToken = accessToken || process.env.MapboxAccessToken;\n  } catch (_a) {\n    // ignore\n  }\n  try {\n    accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  } catch (_b) {\n    // ignore\n  }\n  return accessToken;\n}","map":{"version":3,"names":["transformToViewState","applyViewStateToTransform","cloneTransform","normalizeStyle","deepEqual","pointerEvents","mousedown","mouseup","mouseover","mousemove","click","dblclick","mouseenter","mouseleave","mouseout","contextmenu","touchstart","touchend","touchmove","touchcancel","cameraEvents","movestart","move","moveend","dragstart","drag","dragend","zoomstart","zoom","zoomend","rotatestart","rotate","rotateend","pitchstart","pitch","pitchend","otherEvents","wheel","boxzoomstart","boxzoomend","boxzoomcancel","resize","load","render","idle","remove","data","styledata","sourcedata","error","settingNames","handlerNames","Mapbox","MapClass","props","container","_this","_classCallCheck","_map","_internalUpdate","_inRender","_hoveredFeatures","_deferredEvents","_onEvent","e","cb","type","_onPointerEvent","_updateHover","interactiveLayerIds","features","_queryRenderedFeatures","point","_onCameraEvent","_MapClass","_initialize","_createClass","key","get","_renderTransform","value","setProps","oldProps","settingsChanged","_updateSettings","_createShadowTransform","sizeChanged","_updateSize","viewStateChanged","_updateViewState","_updateStyle","_updateStyleComponents","_updateHandlers","isMoving","redraw","_this2","mapOptions","_objectSpread","initialViewState","accessToken","mapboxAccessToken","getAccessTokenFromEnv","style","mapStyle","viewState","Object","assign","center","longitude","latitude","bearing","gl","getContext","HTMLCanvasElement","prototype","map","padding","setPadding","cursor","getCanvas","renderMap","_render","arg","call","runRenderTaskQueue","_renderTaskQueue","run","_onBeforeRepaint","on","_onAfterRepaint","fireEvent","fire","_fireEvent","bind","transform","width","height","eventName","recycle","getContainer","children","querySelector","savedMaps","push","destroy","_frame","cancel","renderTransform","painter","nextProps","triggerEvents","tr","cameraElevationReference","changed","deferredEvents","currProps","_i","_settingNames","length","propName","concat","toUpperCase","slice","options","diff","styleDiffing","localIdeographFontFamily","setStyle","loaded","light","setLight","fog","setFog","terrain","getSource","source","setTerrain","_i2","_handlerNames","newValue","enable","disable","_this$props$interacti","queryRenderedFeatures","layers","filter","getLayer","_a","shouldTrackHoveredFeatures","onMouseMove","onMouseEnter","onMouseLeave","eventType","wasHovering","isHovering","baseFire","event","properties","_this3","reuse","that","pop","oldContainer","className","childNodes","appendChild","_container","resizeObserver","_resizeObserver","disconnect","observe","bounds","fitBounds","fitBoundsOptions","duration","isStyleLoaded","once","_update","default","location","match","exec","search","process","env","MapboxAccessToken","REACT_APP_MAPBOX_ACCESS_TOKEN","_b"],"sources":["C:\\Users\\HIMANSHI\\Desktop\\Mapping\\frontend\\node_modules\\react-map-gl\\src\\mapbox\\mapbox.ts"],"sourcesContent":["import {transformToViewState, applyViewStateToTransform, cloneTransform} from '../utils/transform';\nimport {normalizeStyle} from '../utils/style-utils';\nimport {deepEqual} from '../utils/deep-equal';\n\nimport type {\n  Transform,\n  ProjectionSpecification,\n  ViewState,\n  ViewStateChangeEvent,\n  DragPanOptions,\n  ZoomRotateOptions,\n  TransformRequestFunction,\n  Light,\n  Fog,\n  Point,\n  TerrainSpecification,\n  MapboxStyle,\n  ImmutableLike,\n  LngLatBoundsLike,\n  FitBoundsOptions,\n  MapMouseEvent,\n  MapLayerMouseEvent,\n  MapLayerTouchEvent,\n  MapWheelEvent,\n  MapBoxZoomEvent,\n  MapStyleDataEvent,\n  MapSourceDataEvent,\n  MapboxEvent,\n  ErrorEvent,\n  MapboxGeoJSONFeature,\n  MapboxMap\n} from '../types';\n\nexport type MapboxProps = Partial<ViewState> & {\n  // Init options\n  mapboxAccessToken?: string;\n\n  /** Camera options used when constructing the Map instance */\n  initialViewState?: Partial<ViewState> & {\n    /** The initial bounds of the map. If bounds is specified, it overrides longitude, latitude and zoom options. */\n    bounds?: LngLatBoundsLike;\n    /** A fitBounds options object to use only when setting the bounds option. */\n    fitBoundsOptions?: FitBoundsOptions;\n  };\n\n  /** If provided, render into an external WebGL context */\n  gl?: WebGLRenderingContext;\n\n  /**\n   * If true, the gl context will be created with MSA antialiasing, which can be useful for antialiasing custom layers.\n   * This is false by default as a performance optimization.\n   * @default false\n   */\n  antialias?: boolean;\n  /**\n   * If true, an attribution control will be added to the map.\n   * @default true\n   */\n  attributionControl?: boolean;\n  /**\n   * Snap to north threshold in degrees.\n   * @default 7\n   */\n  bearingSnap?: number;\n  /**\n   * The max number of pixels a user can shift the mouse pointer during a click for it to be\n   * considered a valid click (as opposed to a mouse drag).\n   * @default 3\n   */\n  clickTolerance?: number;\n  /**\n   * If `true`, Resource Timing API information will be collected for requests made by GeoJSON\n   * and Vector Tile web workers (this information is normally inaccessible from the main\n   * Javascript thread). Information will be returned in a `resourceTiming` property of\n   * relevant `data` events.\n   * @default false\n   */\n  collectResourceTiming?: boolean;\n  /**\n   * If `true` , scroll zoom will require pressing the ctrl or ⌘ key while scrolling to zoom map,\n   * and touch pan will require using two fingers while panning to move the map.\n   * Touch pitch will require three fingers to activate if enabled.\n   */\n  cooperativeGestures?: boolean;\n  /**\n   * If `true`, symbols from multiple sources can collide with each other during collision\n   * detection. If `false`, collision detection is run separately for the symbols in each source.\n   * @default true\n   */\n  crossSourceCollisions?: boolean;\n  /** String or strings to show in an AttributionControl.\n   * Only applicable if options.attributionControl is `true`. */\n  customAttribution?: string | string[];\n  /**\n   * Controls the duration of the fade-in/fade-out animation for label collisions, in milliseconds.\n   * This setting affects all symbol layers. This setting does not affect the duration of runtime\n   * styling transitions or raster tile cross-fading.\n   * @default 300\n   */\n  fadeDuration?: number;\n  /** If true, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.\n   * @default false\n   */\n  failIfMajorPerformanceCaveat?: boolean;\n  /** If `true`, the map's position (zoom, center latitude, center longitude, bearing, and pitch) will be synced with the hash fragment of the page's URL.\n   * For example, `http://path/to/my/page.html#2.59/39.26/53.07/-24.1/60`.\n   * An additional string may optionally be provided to indicate a parameter-styled hash,\n   * e.g. http://path/to/my/page.html#map=2.59/39.26/53.07/-24.1/60&foo=bar, where foo\n   * is a custom parameter and bar is an arbitrary hash distinct from the map hash.\n   */\n  hash?: boolean | string;\n  /** If false, no mouse, touch, or keyboard listeners are attached to the map, so it will not respond to input\n   * @default true\n   */\n  interactive?: boolean;\n  /** A patch to apply to the default localization table for UI strings, e.g. control tooltips.\n   * The `locale` object maps namespaced UI string IDs to translated strings in the target language;\n   * see `src/ui/default_locale.js` for an example with all supported string IDs.\n   * The object may specify all UI strings (thereby adding support for a new translation) or\n   * only a subset of strings (thereby patching the default translation table).\n   */\n  locale?: {[key: string]: string};\n  /**\n   * Overrides the generation of all glyphs and font settings except font-weight keywords\n   * Also overrides localIdeographFontFamily\n   * @default null\n   */\n  localFontFamily?: string;\n  /**\n   * If specified, defines a CSS font-family for locally overriding generation of glyphs in the\n   * 'CJK Unified Ideographs' and 'Hangul Syllables' ranges. In these ranges, font settings from\n   * the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold).\n   * The purpose of this option is to avoid bandwidth-intensive glyph server requests.\n   * @default \"sans-serif\"\n   */\n  localIdeographFontFamily?: string;\n  /**\n   * A string representing the position of the Mapbox wordmark on the map.\n   * @default \"bottom-left\"\n   */\n  logoPosition?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n  /**\n   * The maximum number of tiles stored in the tile cache for a given source. If omitted, the\n   * cache will be dynamically sized based on the current viewport.\n   * @default null\n   */\n  maxTileCacheSize?: number;\n  /**\n   * If true, map will prioritize rendering for performance by reordering layers\n   * If false, layers will always be drawn in the specified order\n   * @default true\n   */\n  optimizeForTerrain?: boolean;\n  /**\n   * If `false`, the map's pitch (tilt) control with \"drag to rotate\" interaction will be disabled.\n   * @default true\n   */\n  pitchWithRotate?: boolean;\n  /** If true, The maps canvas can be exported to a PNG using map.getCanvas().toDataURL();. This is false by default as a performance optimization.\n   * @default false\n   */\n  preserveDrawingBuffer?: boolean;\n  /**\n   * If `false`, the map won't attempt to re-request tiles once they expire per their HTTP\n   * `cacheControl`/`expires` headers.\n   * @default true\n   */\n  refreshExpiredTiles?: boolean;\n  /**\n   * Allows for the usage of the map in automated tests without an accessToken with custom self-hosted test fixtures.\n   * @default null\n   */\n  testMode?: boolean;\n  /**\n   * If  true, the map will automatically resize when the browser window resizes\n   * @default true\n   */\n  trackResize?: boolean;\n  /**\n   * A callback run before the Map makes a request for an external URL. The callback can be\n   * used to modify the url, set headers, or set the credentials property for cross-origin requests.\n   * @default null\n   */\n  transformRequest?: TransformRequestFunction;\n\n  // Handlers\n\n  /**\n   * If true, enable the \"box zoom\" interaction (see BoxZoomHandler)\n   * @default true\n   */\n  boxZoom?: boolean;\n  /**\n   * If true, enable the \"double click to zoom\" interaction (see DoubleClickZoomHandler).\n   * @default true\n   */\n  doubleClickZoom?: boolean;\n  /**\n   * If `true`, the \"drag to pan\" interaction is enabled.\n   * An `Object` value is passed as options to {@link DragPanHandler#enable}.\n   * @default true\n   */\n  dragPan?: boolean | DragPanOptions;\n  /**\n   * If true, enable the \"drag to rotate\" interaction (see DragRotateHandler).\n   * @default true\n   */\n  dragRotate?: boolean;\n  /**\n   * If true, enable keyboard shortcuts (see KeyboardHandler).\n   * @default true\n   */\n  keyboard?: boolean;\n  /**\n   * If `true`, the \"scroll to zoom\" interaction is enabled.\n   * An `Object` value is passed as options to {@link ScrollZoomHandler#enable}.\n   * @default true\n   */\n  scrollZoom?: boolean | ZoomRotateOptions;\n  /**\n   * If `true`, the \"drag to pitch\" interaction is enabled.\n   * An `Object` value is passed as options to {@link TouchPitchHandler#enable}.\n   * @default true\n   */\n  touchPitch?: boolean;\n  /**\n   * If `true`, the \"pinch to rotate and zoom\" interaction is enabled.\n   * An `Object` value is passed as options to {@link TouchZoomRotateHandler#enable}.\n   * @default true\n   */\n  touchZoomRotate?: boolean | ZoomRotateOptions;\n\n  // Constraints\n\n  /** If set, the map is constrained to the given bounds. */\n  maxBounds?: LngLatBoundsLike;\n  /** Maximum pitch of the map. */\n  maxPitch?: number;\n  /** Maximum zoom of the map. */\n  maxZoom?: number;\n  /** Minimum pitch of the map. */\n  minPitch?: number;\n  /** Minimum zoom of the map. */\n  minZoom?: number;\n\n  /** For external controller to override the camera state */\n  viewState?: ViewState & {\n    width: number;\n    height: number;\n  };\n\n  // Styling\n\n  /** Mapbox style */\n  mapStyle?: string | MapboxStyle | ImmutableLike;\n  /** Enable diffing when the map style changes\n   * @default true\n   */\n  styleDiffing?: boolean;\n  /** The fog property of the style. Must conform to the Fog Style Specification .\n   * If `undefined` is provided, removes the fog from the map. */\n  fog?: Fog;\n  /** Light properties of the map. */\n  light?: Light;\n  /** Terrain property of the style. Must conform to the Terrain Style Specification .\n   * If `undefined` is provided, removes terrain from the map. */\n  terrain?: TerrainSpecification;\n  /** Default layers to query on pointer events */\n  interactiveLayerIds?: string[];\n  /** The projection the map should be rendered in\n   * @default \"mercator\"\n   */\n  projection?: ProjectionSpecification | string;\n  /**\n   * If `true`, multiple copies of the world will be rendered, when zoomed out.\n   * @default true\n   */\n  renderWorldCopies?: boolean;\n  /** CSS cursor */\n  cursor?: string;\n\n  // Callbacks\n  onMouseDown?: (e: MapLayerMouseEvent) => void;\n  onMouseUp?: (e: MapLayerMouseEvent) => void;\n  onMouseOver?: (e: MapLayerMouseEvent) => void;\n  onMouseMove?: (e: MapLayerMouseEvent) => void;\n  onClick?: (e: MapLayerMouseEvent) => void;\n  onDblClick?: (e: MapLayerMouseEvent) => void;\n  onMouseEnter?: (e: MapLayerMouseEvent) => void;\n  onMouseLeave?: (e: MapLayerMouseEvent) => void;\n  onMouseOut?: (e: MapLayerMouseEvent) => void;\n  onContextMenu?: (e: MapLayerMouseEvent) => void;\n  onTouchStart?: (e: MapLayerTouchEvent) => void;\n  onTouchEnd?: (e: MapLayerTouchEvent) => void;\n  onTouchMove?: (e: MapLayerTouchEvent) => void;\n  onTouchCancel?: (e: MapLayerTouchEvent) => void;\n\n  onMoveStart?: (e: ViewStateChangeEvent) => void;\n  onMove?: (e: ViewStateChangeEvent) => void;\n  onMoveEnd?: (e: ViewStateChangeEvent) => void;\n  onDragStart?: (e: ViewStateChangeEvent) => void;\n  onDrag?: (e: ViewStateChangeEvent) => void;\n  onDragEnd?: (e: ViewStateChangeEvent) => void;\n  onZoomStart?: (e: ViewStateChangeEvent) => void;\n  onZoom?: (e: ViewStateChangeEvent) => void;\n  onZoomEnd?: (e: ViewStateChangeEvent) => void;\n  onRotateStart?: (e: ViewStateChangeEvent) => void;\n  onRotate?: (e: ViewStateChangeEvent) => void;\n  onRotateEnd?: (e: ViewStateChangeEvent) => void;\n  onPitchStart?: (e: ViewStateChangeEvent) => void;\n  onPitch?: (e: ViewStateChangeEvent) => void;\n  onPitchEnd?: (e: ViewStateChangeEvent) => void;\n\n  onWheel?: (e: MapWheelEvent) => void;\n  onBoxZoomStart?: (e: MapBoxZoomEvent) => void;\n  onBoxZoomEnd?: (e: MapBoxZoomEvent) => void;\n  onBoxZoomCancel?: (e: MapBoxZoomEvent) => void;\n\n  onResize?: (e: MapboxEvent) => void;\n  onLoad?: (e: MapboxEvent) => void;\n  onRender?: (e: MapboxEvent) => void;\n  onIdle?: (e: MapboxEvent) => void;\n  onError?: (e: ErrorEvent) => void;\n  onRemove?: (e: MapboxEvent) => void;\n  onData?: (e: MapStyleDataEvent | MapSourceDataEvent) => void;\n  onStyleData?: (e: MapStyleDataEvent) => void;\n  onSourceData?: (e: MapSourceDataEvent) => void;\n};\n\nconst pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nconst settingNames: (keyof MapboxProps)[] = [\n  'minZoom',\n  'maxZoom',\n  'minPitch',\n  'maxPitch',\n  'maxBounds',\n  'projection',\n  'renderWorldCopies'\n];\nconst handlerNames: (keyof MapboxProps)[] = [\n  'scrollZoom',\n  'boxZoom',\n  'dragRotate',\n  'dragPan',\n  'keyboard',\n  'doubleClickZoom',\n  'touchZoomRotate',\n  'touchPitch'\n];\n\n/**\n * A wrapper for mapbox-gl's Map class\n */\nexport default class Mapbox {\n  private _MapClass: typeof MapboxMap;\n  // mapboxgl.Map instance. Not using type here because we are accessing\n  // private members and methods\n  private _map: any = null;\n  // User-supplied props\n  props: MapboxProps;\n\n  // Mapbox map is stateful.\n  // During method calls/user interactions, map.transform is mutated and\n  // deviate from user-supplied props.\n  // In order to control the map reactively, we shadow the transform\n  // with the one below, which reflects the view state resolved from\n  // both user-supplied props and the underlying state\n  private _renderTransform: Transform;\n\n  // Internal states\n  private _internalUpdate: boolean = false;\n  private _inRender: boolean = false;\n  private _hoveredFeatures: MapboxGeoJSONFeature[] = null;\n  private _deferredEvents: {\n    move: boolean;\n    zoom: boolean;\n    pitch: boolean;\n    rotate: boolean;\n  } = {\n    move: false,\n    zoom: false,\n    pitch: false,\n    rotate: false\n  };\n\n  static savedMaps: Mapbox[] = [];\n\n  constructor(MapClass: typeof MapboxMap, props: MapboxProps, container: HTMLDivElement) {\n    this._MapClass = MapClass;\n    this.props = props;\n    this._initialize(container);\n  }\n\n  get map(): MapboxMap {\n    return this._map as MapboxMap;\n  }\n\n  get transform(): Transform {\n    return this._renderTransform;\n  }\n\n  setProps(props: MapboxProps) {\n    const oldProps = this.props;\n    this.props = props;\n\n    const settingsChanged = this._updateSettings(props, oldProps);\n    if (settingsChanged) {\n      this._createShadowTransform(this._map);\n    }\n    const sizeChanged = this._updateSize(props);\n    const viewStateChanged = this._updateViewState(props, true);\n    this._updateStyle(props, oldProps);\n    this._updateStyleComponents(props, oldProps);\n    this._updateHandlers(props, oldProps);\n\n    // If 1) view state has changed to match props and\n    //    2) the props change is not triggered by map events,\n    // it's driven by an external state change. Redraw immediately\n    if (settingsChanged || sizeChanged || (viewStateChanged && !this._map.isMoving())) {\n      this.redraw();\n    }\n  }\n\n  static reuse(props: MapboxProps, container: HTMLDivElement) {\n    const that = Mapbox.savedMaps.pop();\n    if (!that) {\n      return null;\n    }\n\n    const map = that.map;\n    // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n    // intoto the new container from the props.\n    // Step 1: reparenting child nodes from old container to new container\n    const oldContainer = map.getContainer();\n    container.className = oldContainer.className;\n    while (oldContainer.childNodes.length > 0) {\n      container.appendChild(oldContainer.childNodes[0]);\n    }\n    // Step 2: replace the internal container with new container from the react component\n    // @ts-ignore\n    map._container = container;\n\n    // With maplibre-gl as mapLib, map uses ResizeObserver to observe when its container resizes.\n    // When reusing the saved map, we need to disconnect the observer and observe the new container.\n    // Step 3: telling the ResizeObserver to disconnect and observe the new container\n    // @ts-ignore\n    const resizeObserver = map._resizeObserver;\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n      resizeObserver.observe(container);\n    }\n\n    // Step 4: apply new props\n    that.setProps({...props, styleDiffing: false});\n    map.resize();\n    const {initialViewState} = props;\n    if (initialViewState) {\n      if (initialViewState.bounds) {\n        map.fitBounds(initialViewState.bounds, {...initialViewState.fitBoundsOptions, duration: 0});\n      } else {\n        that._updateViewState(initialViewState, false);\n      }\n    }\n\n    // Simulate load event\n    if (map.isStyleLoaded()) {\n      map.fire('load');\n    } else {\n      map.once('styledata', () => map.fire('load'));\n    }\n\n    // Force reload\n    // @ts-ignore\n    map._update();\n    return that;\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _initialize(container: HTMLDivElement) {\n    const {props} = this;\n    const mapOptions = {\n      ...props,\n      ...props.initialViewState,\n      accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n      container,\n      style: normalizeStyle(props.mapStyle)\n    };\n\n    const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n    Object.assign(mapOptions, {\n      center: [viewState.longitude || 0, viewState.latitude || 0],\n      zoom: viewState.zoom || 0,\n      pitch: viewState.pitch || 0,\n      bearing: viewState.bearing || 0\n    });\n\n    if (props.gl) {\n      // eslint-disable-next-line\n      const getContext = HTMLCanvasElement.prototype.getContext;\n      // Hijack canvas.getContext to return our own WebGLContext\n      // This will be called inside the mapboxgl.Map constructor\n      // @ts-expect-error\n      HTMLCanvasElement.prototype.getContext = () => {\n        // Unhijack immediately\n        HTMLCanvasElement.prototype.getContext = getContext;\n        return props.gl;\n      };\n    }\n\n    const map: any = new this._MapClass(mapOptions);\n    // Props that are not part of constructor options\n    if (viewState.padding) {\n      map.setPadding(viewState.padding);\n    }\n    if (props.cursor) {\n      map.getCanvas().style.cursor = props.cursor;\n    }\n    this._createShadowTransform(map);\n\n    // Hack\n    // Insert code into map's render cycle\n    const renderMap = map._render;\n    map._render = (arg: number) => {\n      this._inRender = true;\n      renderMap.call(map, arg);\n      this._inRender = false;\n    };\n    const runRenderTaskQueue = map._renderTaskQueue.run;\n    map._renderTaskQueue.run = (arg: number) => {\n      runRenderTaskQueue.call(map._renderTaskQueue, arg);\n      this._onBeforeRepaint();\n    };\n    map.on('render', () => this._onAfterRepaint());\n    // Insert code into map's event pipeline\n    const fireEvent = map.fire;\n    map.fire = this._fireEvent.bind(this, fireEvent);\n\n    // add listeners\n    map.on('resize', () => {\n      this._renderTransform.resize(map.transform.width, map.transform.height);\n    });\n    map.on('styledata', () => this._updateStyleComponents(this.props, {}));\n    map.on('sourcedata', () => this._updateStyleComponents(this.props, {}));\n    for (const eventName in pointerEvents) {\n      map.on(eventName, this._onPointerEvent);\n    }\n    for (const eventName in cameraEvents) {\n      map.on(eventName, this._onCameraEvent);\n    }\n    for (const eventName in otherEvents) {\n      map.on(eventName, this._onEvent);\n    }\n    this._map = map;\n  }\n  /* eslint-enable complexity,max-statements */\n\n  recycle() {\n    // Clean up unnecessary elements before storing for reuse.\n    const container = this.map.getContainer();\n    const children = container.querySelector('[mapboxgl-children]');\n    children?.remove();\n\n    Mapbox.savedMaps.push(this);\n  }\n\n  destroy() {\n    this._map.remove();\n  }\n\n  // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n  // render cycle, which is managed by Mapbox's animation loop.\n  // This removes the synchronization issue caused by requestAnimationFrame.\n  redraw() {\n    const map = this._map;\n    // map._render will throw error if style does not exist\n    // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n    //   /src/ui/map.js#L1834\n    if (!this._inRender && map.style) {\n      // cancel the scheduled update\n      if (map._frame) {\n        map._frame.cancel();\n        map._frame = null;\n      }\n      // the order is important - render() may schedule another update\n      map._render();\n    }\n  }\n\n  _createShadowTransform(map: any) {\n    const renderTransform = cloneTransform(map.transform);\n    map.painter.transform = renderTransform;\n\n    this._renderTransform = renderTransform;\n  }\n\n  /* Trigger map resize if size is controlled\n     @param {object} nextProps\n     @returns {bool} true if size has changed\n   */\n  _updateSize(nextProps: MapboxProps): boolean {\n    // Check if size is controlled\n    const {viewState} = nextProps;\n    if (viewState) {\n      const map = this._map;\n      if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n        map.resize();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Adapted from map.jumpTo\n  /* Update camera to match props\n     @param {object} nextProps\n     @param {bool} triggerEvents - should fire camera events\n     @returns {bool} true if anything is changed\n   */\n  _updateViewState(nextProps: MapboxProps, triggerEvents: boolean): boolean {\n    if (this._internalUpdate) {\n      return false;\n    }\n    const map = this._map;\n\n    const tr = this._renderTransform;\n    // Take a snapshot of the transform before mutation\n    const {zoom, pitch, bearing} = tr;\n    const isMoving = map.isMoving();\n\n    if (isMoving) {\n      // All movement of the camera is done relative to the sea level\n      tr.cameraElevationReference = 'sea';\n    }\n    const changed = applyViewStateToTransform(tr, {\n      ...transformToViewState(map.transform),\n      ...nextProps\n    });\n    if (isMoving) {\n      // Reset camera reference\n      tr.cameraElevationReference = 'ground';\n    }\n\n    if (changed && triggerEvents) {\n      const deferredEvents = this._deferredEvents;\n      // Delay DOM control updates to the next render cycle\n      deferredEvents.move = true;\n      deferredEvents.zoom ||= zoom !== tr.zoom;\n      deferredEvents.rotate ||= bearing !== tr.bearing;\n      deferredEvents.pitch ||= pitch !== tr.pitch;\n    }\n\n    // Avoid manipulating the real transform when interaction/animation is ongoing\n    // as it would interfere with Mapbox's handlers\n    if (!isMoving) {\n      applyViewStateToTransform(map.transform, nextProps);\n    }\n\n    return changed;\n  }\n\n  /* Update camera constraints and projection settings to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateSettings(nextProps: MapboxProps, currProps: MapboxProps): boolean {\n    const map = this._map;\n    let changed = false;\n    for (const propName of settingNames) {\n      if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n        changed = true;\n        map[`set${propName[0].toUpperCase()}${propName.slice(1)}`](nextProps[propName]);\n      }\n    }\n    return changed;\n  }\n\n  /* Update map style to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if style is changed\n   */\n  _updateStyle(nextProps: MapboxProps, currProps: MapboxProps): boolean {\n    if (nextProps.cursor !== currProps.cursor) {\n      this._map.getCanvas().style.cursor = nextProps.cursor;\n    }\n    if (nextProps.mapStyle !== currProps.mapStyle) {\n      const options: any = {\n        diff: nextProps.styleDiffing\n      };\n      if ('localIdeographFontFamily' in nextProps) {\n        options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n      }\n      this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);\n      return true;\n    }\n    return false;\n  }\n\n  /* Update fog, light and terrain to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateStyleComponents(nextProps: MapboxProps, currProps: MapboxProps): boolean {\n    const map = this._map;\n    let changed = false;\n    if (map.style.loaded()) {\n      if ('light' in nextProps && !deepEqual(nextProps.light, currProps.light)) {\n        changed = true;\n        map.setLight(nextProps.light);\n      }\n      if ('fog' in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {\n        changed = true;\n        map.setFog(nextProps.fog);\n      }\n      if ('terrain' in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {\n        if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n          changed = true;\n          map.setTerrain(nextProps.terrain);\n        }\n      }\n    }\n    return changed;\n  }\n\n  /* Update interaction handlers to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateHandlers(nextProps: MapboxProps, currProps: MapboxProps): boolean {\n    const map = this._map;\n    let changed = false;\n    for (const propName of handlerNames) {\n      const newValue = nextProps[propName];\n      if (!deepEqual(newValue, currProps[propName])) {\n        changed = true;\n        if (newValue) {\n          map[propName].enable(newValue);\n        } else {\n          map[propName].disable();\n        }\n      }\n    }\n    return changed;\n  }\n\n  _onEvent = (e: MapboxEvent) => {\n    // @ts-ignore\n    const cb = this.props[otherEvents[e.type]];\n    if (cb) {\n      cb(e);\n    }\n  };\n\n  private _queryRenderedFeatures(point: Point) {\n    const map = this._map;\n    const {interactiveLayerIds = []} = this.props;\n    try {\n      return map.queryRenderedFeatures(point, {\n        layers: interactiveLayerIds.filter(map.getLayer.bind(map))\n      });\n    } catch {\n      // May fail if style is not loaded\n      return [];\n    }\n  }\n\n  _updateHover(e: MapMouseEvent) {\n    const {props} = this;\n    const shouldTrackHoveredFeatures =\n      props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n\n    if (shouldTrackHoveredFeatures) {\n      const eventType = e.type;\n      const wasHovering = this._hoveredFeatures?.length > 0;\n      const features = this._queryRenderedFeatures(e.point);\n      const isHovering = features.length > 0;\n\n      if (!isHovering && wasHovering) {\n        e.type = 'mouseleave';\n        this._onPointerEvent(e);\n      }\n      this._hoveredFeatures = features;\n      if (isHovering && !wasHovering) {\n        e.type = 'mouseenter';\n        this._onPointerEvent(e);\n      }\n      e.type = eventType;\n    } else {\n      this._hoveredFeatures = null;\n    }\n  }\n\n  _onPointerEvent = (e: MapLayerMouseEvent | MapLayerTouchEvent) => {\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      this._updateHover(e);\n    }\n\n    // @ts-ignore\n    const cb = this.props[pointerEvents[e.type]];\n    if (cb) {\n      if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n        e.features = this._hoveredFeatures || this._queryRenderedFeatures(e.point);\n      }\n      cb(e);\n      delete e.features;\n    }\n  };\n\n  _onCameraEvent = (e: ViewStateChangeEvent) => {\n    if (!this._internalUpdate) {\n      // @ts-ignore\n      const cb = this.props[cameraEvents[e.type]];\n      if (cb) {\n        cb(e);\n      }\n    }\n    if (e.type in this._deferredEvents) {\n      this._deferredEvents[e.type] = false;\n    }\n  };\n\n  _fireEvent(baseFire: Function, event: string | MapboxEvent, properties?: object) {\n    const map = this._map;\n    const tr = map.transform;\n\n    const eventType = typeof event === 'string' ? event : event.type;\n    if (eventType === 'move') {\n      this._updateViewState(this.props, false);\n    }\n    if (eventType in cameraEvents) {\n      if (typeof event === 'object') {\n        (event as unknown as ViewStateChangeEvent).viewState = transformToViewState(tr);\n      }\n      if (this._map.isMoving()) {\n        // Replace map.transform with ours during the callbacks\n        map.transform = this._renderTransform;\n        baseFire.call(map, event, properties);\n        map.transform = tr;\n\n        return map;\n      }\n    }\n    baseFire.call(map, event, properties);\n\n    return map;\n  }\n\n  // All camera manipulations are complete, ready to repaint\n  _onBeforeRepaint() {\n    const map = this._map;\n\n    // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n    this._internalUpdate = true;\n    for (const eventType in this._deferredEvents) {\n      if (this._deferredEvents[eventType]) {\n        map.fire(eventType);\n      }\n    }\n    this._internalUpdate = false;\n\n    const tr = this._map.transform;\n    // Make sure camera matches the current props\n    this._map.transform = this._renderTransform;\n\n    this._onAfterRepaint = () => {\n      // Restores camera state before render/load events are fired\n      this._map.transform = tr;\n    };\n  }\n\n  _onAfterRepaint: () => void;\n}\n\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\nfunction getAccessTokenFromEnv(): string {\n  let accessToken = null;\n\n  /* global location, process */\n  if (typeof location !== 'undefined') {\n    const match = /access_token=([^&\\/]*)/.exec(location.search);\n    accessToken = match && match[1];\n  }\n\n  // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n  try {\n    accessToken = accessToken || process.env.MapboxAccessToken;\n  } catch {\n    // ignore\n  }\n\n  try {\n    accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  } catch {\n    // ignore\n  }\n\n  return accessToken;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}